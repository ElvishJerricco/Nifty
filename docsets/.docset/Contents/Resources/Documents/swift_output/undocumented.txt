Json.swift
	public protocol JsonReader
	public protocol JsonWriter
	public protocol JsonDeserializable
	init(inout json: JsonReader) throws
	public protocol JsonSerializable
	func serialize(inout json json: JsonWriter)
Continuation.swift
	public struct Continuation<R, A>
	public let run : (A -> R) -> R
	public init(_ run: (A -> R) -> R)
	public struct Continuation&lt;R, A&gt;
	public func map<B>(f: A -> B) -> Continuation<R, B>
	public struct Continuation&lt;R, A&gt;
	public func apply<B>(f: Continuation<R, A -> B>) -> Continuation<R, B>
	public struct Continuation&lt;R, A&gt;
	public static func of(a: A) -> Continuation<R, A>
	public func flatMap<B>(f: A -> Continuation<R, B>) -> Continuation<R, B>
	public func callcc<R, A, B>(f: (A -> Continuation<R, B>) -> Continuation<R, A>) -> Continuation<R, A>
Stream.swift
	public func <^><T, U>(f: T -> U, stream: Stream<T>) -> Stream<U>
	public func <*><T, U>(f: Stream<T -> U>, stream: Stream<T>) -> Stream<U>
	public func >>==<T, U>(stream: Stream<T>, f: T -> Stream<U>) -> Stream<U>
	public func +<T>(a: Stream<T>, b: Stream<T>) -> Stream<T>
Either.swift
	public enum Either<L, R>
	case Left(L)
	case Right(R)
	public enum Either&lt;L, R&gt;
	public func map<U>(f: R -> U) -> Either<L, U>
	public func <^><L, R, U>(f: R -> U, either: Either<L, R>) -> Either<L, U>
	public enum Either&lt;L, R&gt;
	public func apply<U>(fn: Either<L, R -> U>) -> Either<L, U>
	public func <*><L, A, B>(f: Either<L, A -> B>, a: Either<L, A>) -> Either<L, B>
	public enum Either&lt;L, R&gt;
	public static func of<L, R>(r: R) -> Either<L, R>
	public func flatMap<U>(f: R -> Either<L, U>) -> Either<L, U>
	public func >>==<L, R, U>(either: Either<L, R>, f: R -> Either<L, U>) -> Either<L, U>
	public enum Either&lt;L, R&gt;
	public func leftMap<U>(f: L -> U) -> Either<U, R>
	public enum Either&lt;L, R&gt;
	public func leftApply<U>(resultFunc: Either<L -> U, R>) -> Either<U, R>
	public enum Either&lt;L, R&gt;
	public static func leftOf<L, R>(l: L) -> Either<L, R>
	public func leftFlatMap<U>(f: L -> Either<U, R>) -> Either<U, R>
Channel.swift
	public let cont: Continuation<(), T>
	public init(_ cont: Continuation<(), T>)
	public init(_ cont: (T -> ()) -> ())
	public func <^><T, U>(f: T -> U, channel: Channel<T>) -> Channel<U>
	public func <*><A, B>(f: Channel<A -> B>, a: Channel<A>) -> Channel<B>
	public func >>==<T, U>(channel: Channel<T>, f: T -> Channel<U>) -> Channel<U>
	public func +<T>(a: Channel<T>, b: Channel<T>) -> Channel<T>
Lock.swift
	public class Lock<T>
	public init(_ value: T)
	public func get() -> Future<T>
	public func set(newValue: T)
	public func mutate(handler: T -> T)
	public func acquire<U>(handler: inout T -> U) -> Future<U>
Future.swift
	public class Promise<T>
	public init()
	public func complete(t: T, queue: DispatchQueue = Dispatch.globalQueue)
	public var future: Future<T>
	public struct Future<T>
	public let cont: Continuation<(), T>
	public init(_ cont: Continuation<(), T>)
	public init(_ cont: (T -> ()) -> ())
	public struct Future&lt;T&gt;
	public func map<U>(f: T -> U) -> Future<U>
	public func <^><T, U>(f: T -> U, future: Future<T>) -> Future<U>
	public struct Future&lt;T&gt;
	public func apply<U>(futureFunc: Future<T -> U>) -> Future<U>
	public func <*><A, B>(f: Future<A -> B>, a: Future<A>) -> Future<B>
	public struct Future&lt;T&gt;
	public static func of<T>(t: T) -> Future<T>
	public func flatMap<U>(f: T -> Future<U>) -> Future<U>
	public func >>==<T, U>(future: Future<T>, f: T -> Future<U>) -> Future<U>
	public struct Future&lt;T&gt;
	public func onComplete(handler: T -> ())
	public func future<T>(f: () -> T) -> Future<T>
	public func barrierFuture<T>(f: () -> T) -> Future<T>
	public func future<T>(queue: DispatchQueue, f: () -> T) -> Future<T>
	public struct Future&lt;T&gt;
	public func wait() -> T
	public func wait(time: DispatchTime) -> T?
Curry.swift
	public func curry<A, B, C>(fn: (A, B) -> C) -> A -> B -> C
	public func curry<A, B, C, D>(fn: (A, B, C) -> D) -> A -> B -> C -> D
	public func curry<A, B, C, D, E>(fn: (A, B, C, D) -> E) -> A -> B -> C -> D -> E
	public func curry<A, B, C, D, E, F>(fn: (A, B, C, D, E) -> F) -> A -> B -> C -> D -> E -> F
	public func curry<A, B, C, D, E, F, G>(fn: (A, B, C, D, E, F) -> G) -> A -> B -> C -> D -> E -> F -> G
	public func curry<A, B, C, D, E, F, G, H>(fn: (A, B, C, D, E, F, G) -> H) -> A -> B -> C -> D -> E -> F -> G -> H
	public func curry<A, B, C, D, E, F, G, H, I>(fn: (A, B, C, D, E, F, G, H) -> I) -> A -> B -> C -> D -> E -> F -> G -> H -> I
Operators.swift
	public func *<A, B, C>(g: B -> C, f: A -> B) -> A -> C
	public func +<T>(element: T, array: [T]) -> [T]
	public func +<T>(array: [T], element: T) -> [T]
